# -*- coding: utf-8 -*-
"""Copy of face_matching_ekyc.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1dfZRQf8qVBxeRAwvTHIiDbqAyfQIeo1S
"""

# !pip install tensorflow_gpu==1.15.0

# !pip install git+https://github.com/rcmalli/keras-vggface.git

# !pip install mtcnn

# pip install keras==2.3.1

# !pip uninstall h5py
# !pip install h5py==2.10.0

import keras_vggface
import matplotlib.pyplot as plt
import mtcnn
import numpy as np
from PIL import Image
from mtcnn.mtcnn import MTCNN
import cv2
from numpy import asarray
from keras_vggface.vggface import VGGFace
from keras_vggface.utils import preprocess_input
from keras_vggface.utils import decode_predictions
from scipy.spatial.distance import cosine


#Open web_cam, take images and close camera
def take_img_from_cam():
    cam = cv2.VideoCapture(0)

    cv2.namedWindow("test")

    img_counter = 0

    while True:
        ret, frame = cam.read()
        if not ret:
            print("failed to grab frame")
            break
        cv2.imshow("test", frame)
        k = cv2.waitKey(1)
        if k % 256 == 27:
        # ESC pressed
          print("Escape hit, closing...")
          break
        elif k % 256 == 32:
        # SPACE pressed
          img_name = "opencv_frame_{}.jpg".format(img_counter)
          cv2.imwrite(img_name, frame)
          print("{} written!".format(img_name))
          img_counter += 1
    cam.release()
    cv2.destroyAllWindows()
    return


# extract a single face from a given photograph
def extract_face(filename, required_size=(224, 224)):
    # load image from file
    pixels = plt.imread(filename)

    # create the detector, using default weights
    detector = MTCNN()
    # detect faces in the image
    results = detector.detect_faces(pixels)
    # extract the bounding box from the first face
    x1, y1, width, height = results[0]['box']
    x2, y2 = x1 + width, y1 + height
    # extract the face
    face = pixels[y1:y2, x1:x2]
    # resize pixels to the model size
    image = Image.fromarray(face)
    image = image.resize(required_size)
    face_array = asarray(image)
    return face_array


# load the photo and extract the face
# pixels = extract_face('image_1.jpg')

# plot the extracted face
# plt.imshow(pixels)
# show the plot

# create a vggface model
model = VGGFace(model='resnet50', include_top=False, input_shape=(224, 224, 3), pooling='avg')


# extract faces and calculate face embeddings for a list of photo files
def get_embeddings(filenames):
    # extract faces
    faces = [extract_face(f) for f in filenames]
    # convert into an array of samples
    samples = asarray(faces, 'float32')
    # prepare the face for the model, e.g. center pixels
    samples = preprocess_input(samples, version=2)
    # create a vggface model
    model = VGGFace(model='resnet50', include_top=False, input_shape=(224, 224, 3), pooling='avg')
    # perform prediction
    yhat = model.predict(samples)
    return yhat,faces


# determine if a candidate face is a match for a known face
def is_match(known_embedding, candidate_embedding, thresh=0.5):
    # calculate distance between embeddings
    score = cosine(known_embedding, candidate_embedding)
    if score <= thresh:
        print('face is a match')
        print('Cosine similarity :',score)
    else:
        print('face is NOT a Match ')
        print('Cosine similarity :', score)
#taking pictures of voters id and selfie
take_img_from_cam()

# define filenames
filenames = ['opencv_frame_0.jpg', 'opencv_frame_1.jpg']

# get embeddings file filenames
embeddings,faces = get_embeddings(filenames)
# define sharon stone
#sharon_id = embeddings[0]
# verify known photos of sharon
# print('Positive Tests')
is_match(embeddings[0], embeddings[1])
# is_match(embeddings[0], embeddings[2])
# verify known photos of other people
cv2.imshow('original_image',faces[0])


# Capturing real time video stream.
video_capture = cv2.VideoCapture(0)
# get vcap property
width  = video_capture.get(3) # float
height = video_capture.get(4) # float
press_flag = False
cmd = ""
